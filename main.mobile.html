<!DOCTYPE html>
<html lang="VN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ðŸ’— QuÃ  Valentine cho em (Mobile)</title>

  <style>
    html, body { width:100%; height:100%; margin:0; overflow:hidden; background:#000; font-family: 'Times New Roman', serif; }
    #canvas-container { width:100vw; height:100dvh; position:absolute; inset:0; z-index:1; }
    #canvas-container canvas { display:block; width:100%; height:100%; }

    #ui-layer {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      z-index: 10; pointer-events: none;
      display: flex; flex-direction: column;
      align-items: center;
      padding-top: 18px;
      box-sizing: border-box;
    }

    #loader {
      position: absolute; inset:0;
      background: #000; z-index: 100;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      transition: opacity 0.8s ease-out;
    }
    .loader-text { color:#fdfdfd; font-size:12px; letter-spacing:3px; margin-top:16px; text-transform:uppercase; font-weight:100; }
    .spinner {
      width:36px; height:36px; border:1px solid rgba(255,255,255,.2);
      border-top:1px solid #fff; border-radius:50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { 0%{transform:rotate(0deg)} 100%{transform:rotate(360deg)} }

    h1{
      color:#fff; font-size:34px; margin:0; font-weight:400;
      letter-spacing:3px;
      text-shadow:0 0 36px rgba(255,255,255,.55);
      background: linear-gradient(to bottom, #fff, #fff);
      -webkit-background-clip:text; -webkit-text-fill-color:transparent;
      font-family:'Cinzel','Times New Roman',serif;
      opacity:.92;
    }

    #webcam-wrapper {
      position:absolute; bottom:20px; right:20px;
      width:120px; height:90px;
      border:1px solid rgba(255,255,255,0.1);
      overflow:hidden; opacity:0;
      pointer-events:none;
    }
  </style>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
        "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
      }
    }
  </script>
</head>

<body>
  <div id="loader">
    <div class="spinner"></div>
    <div class="loader-text">Loading ðŸ’—</div>
  </div>

  <div id="canvas-container"></div>

  <div id="ui-layer">
    <h1></h1>
  </div>

  <div id="webcam-wrapper">
    <video id="webcam" autoplay playsinline style="display:none;"></video>
    <canvas id="webcam-preview"></canvas>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
    import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

    // ============ MOBILE FLAGS ============
    const IS_MOBILE = true; // file mobile => luÃ´n true
    const MOBILE_RENDER_SCALE = 0.75; // composer render nhá» hÆ¡n Ä‘á»ƒ nháº¹ GPU
    const MOBILE_FPS_STEP = 1 / 30;   // ~30fps
    let mobileAcc = 0;

    const CONFIG = {
      colors: {
        bg: 0x000000,
        champagneGold: 0xffd966,
        deepGreen: 0x03180a,
        accentRed: 0x990000,
        textParticles: 0xff4d8d
      },
      particles: {
        // nháº¹ hÆ¡n cho mobile
        count: 650,
        dustCount: 650,
        textCount: 6500,
        textScale: 1.0,
        heartScale: 0.35,
        heartThick: 5.0,
        blinkAmplitude: 0.16,
        blinkSpeedMin: 2.5,
        blinkSpeedMax: 5.5,
        driftAmplitude: 0.25,
        driftSpeedMin: 0.2,
        driftSpeedMax: 0.6,
        rimColor: 0xffe6f0,
        rimStrength: 0.06,
        heartFocusScale: 2.4,
        heartGlobalScale: 1.3
      },
      camera: { z: 50 }
    };

    // pixelRatio cap cho mobile (giáº£m nÃ³ng)
    const PIXEL_RATIO_CAP = 1.0;

    const INITIAL_PHOTOS = ["1.jpg", "2.jpg", "3.jpg"];

    const STATE = {
      mode: 'TREE',
      focusTarget: null,
      textFormed: false,
      prevMode: null,
      hand: { detected: false, x: 0, y: 0 },
      rotation: { x: 0, y: 0 }
    };

    let scene, camera, renderer, composer;
    let mainGroup;
    let clock = new THREE.Clock();
    let particleSystem = [];
    let photoMeshGroup = new THREE.Group();
    let handLandmarker, video;
    let caneTexture;
    let isPaused = false;

    // click focus
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    const photoRoots = [];
    let currentPhotoIndex = 0;
    let focusBackdrop = null;

    // text cloud
    let textCloud = null;
    let textGeom = null;
    let textPosArr = null;
    let textTargetArr = null;
    let textScatterArr = null;
    let textUpdateCursor = 0;

    // ========= canvas size (Ä‘Ãºng khung mobile + devtools) =========
    function getCanvasSize() {
      const el = document.getElementById('canvas-container');
      const rect = el.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width));
      const h = Math.max(1, Math.floor(rect.height));
      return { w, h };
    }

    function resizeAll() {
      const { w, h } = getCanvasSize();
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);

      if (composer && typeof composer.setSize === 'function') {
        composer.setSize(Math.floor(w * MOBILE_RENDER_SCALE), Math.floor(h * MOBILE_RENDER_SCALE));
      }
    }

    async function init() {
      initThree();
      setupEnvironment();
      setupLights();
      createTextures();
      createParticles();
      loadInitialPhotos();
      createDustAndTextCloud();
      setupPostProcessing();
      setupEvents();

      // mediapipe init (defer)
      setTimeout(() => {
        initMediaPipe().catch(() => { handLandmarker = null; });
      }, 2200);

      const loader = document.getElementById('loader');
      if (loader) {
        loader.style.opacity = 0;
        setTimeout(() => loader.remove(), 800);
      }

      animate();
    }

    function initThree() {
      const container = document.getElementById('canvas-container');
      scene = new THREE.Scene();
      scene.background = new THREE.Color(CONFIG.colors.bg);
      scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.01);

      const { w, h } = getCanvasSize();
      camera = new THREE.PerspectiveCamera(55, w / h, 0.1, 1000); // mobile: fov lá»›n hÆ¡n
      camera.position.set(0, 2, 65); // mobile: lÃ¹i ra

      renderer = new THREE.WebGLRenderer({
        antialias: false, // mobile: táº¯t AA
        alpha: false,
        powerPreference: "high-performance"
      });

      renderer.setSize(w, h);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, PIXEL_RATIO_CAP));
      renderer.toneMapping = THREE.ReinhardToneMapping;
      renderer.toneMappingExposure = 1.35;
      container.appendChild(renderer.domElement);

      // backdrop focus
      const bgGeo = new THREE.PlaneGeometry(60, 40);
      const bgMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.65, depthWrite: false });
      focusBackdrop = new THREE.Mesh(bgGeo, bgMat);
      focusBackdrop.position.set(0, 0, -12);
      focusBackdrop.visible = false;
      camera.add(focusBackdrop);
      scene.add(camera);

      createStarfield();
      mainGroup = new THREE.Group();
      scene.add(mainGroup);
    }

    function setupEnvironment() {
      const pmremGenerator = new THREE.PMREMGenerator(renderer);
      scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
      pmremGenerator.dispose();
    }

    function setupLights() {
      scene.add(new THREE.AmbientLight(0xffe6f2, 0.40));
      const innerLight = new THREE.PointLight(0xff77aa, 1.25, 22);
      innerLight.position.set(0, 5, 0);
      mainGroup.add(innerLight);
      const spotGold = new THREE.SpotLight(0xff99cc, 520);
      spotGold.position.set(30, 40, 40);
      spotGold.angle = 0.5;
      spotGold.penumbra = 0.5;
      scene.add(spotGold);
      const spotBlue = new THREE.SpotLight(0xff66aa, 280);
      spotBlue.position.set(-30, 20, -30);
      scene.add(spotBlue);
      const fill = new THREE.DirectionalLight(0xffd6e6, 0.5);
      fill.position.set(0, 0, 50);
      scene.add(fill);
    }

    function setupPostProcessing() {
      const { w, h } = getCanvasSize();

      const renderScene = new RenderPass(scene, camera);
      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(w, h),
        0.9, 0.5, 0.85
      );

      // mobile bloom nháº¹
      bloomPass.threshold = 0.92;
      bloomPass.strength  = 0.22;
      bloomPass.radius    = 0.35;

      composer = new EffectComposer(renderer);
      composer.addPass(renderScene);
      composer.addPass(bloomPass);

      composer.setSize(Math.floor(w * MOBILE_RENDER_SCALE), Math.floor(h * MOBILE_RENDER_SCALE));
    }

    function createTextures() {
      const canvas = document.createElement('canvas');
      canvas.width = 128; canvas.height = 128;
      const ctx = canvas.getContext('2d');

      ctx.fillStyle = '#fff7fb';
      ctx.fillRect(0, 0, 128, 128);

      ctx.fillStyle = '#ffc0cb';
      ctx.beginPath();
      for (let i = -128; i < 256; i += 32) {
        ctx.moveTo(i, 0);
        ctx.lineTo(i + 32, 128);
        ctx.lineTo(i + 16, 128);
        ctx.lineTo(i - 16, 0);
      }
      ctx.fill();

      caneTexture = new THREE.CanvasTexture(canvas);
      caneTexture.wrapS = THREE.RepeatWrapping;
      caneTexture.wrapT = THREE.RepeatWrapping;
      caneTexture.repeat.set(3, 3);
    }

    class Particle {
      constructor(mesh, type, isDust = false) {
        this.mesh = mesh;
        this.type = type;
        this.isDust = isDust;

        this.posTree = new THREE.Vector3();
        this.posScatter = new THREE.Vector3();

        this.baseScale = mesh.scale.x || 1;

        const speedMult = (type === 'PHOTO') ? 0.12 : 1.7;
        this.spinSpeed = new THREE.Vector3(
          (Math.random() - 0.5) * speedMult,
          (Math.random() - 0.5) * speedMult,
          (Math.random() - 0.5) * speedMult
        );

        this.pulsePhase = Math.random() * Math.PI * 2;
        this.blinkSpeed = CONFIG.particles.blinkSpeedMin + Math.random() * (CONFIG.particles.blinkSpeedMax - CONFIG.particles.blinkSpeedMin);

        this.driftPhase = Math.random() * Math.PI * 2;
        this.driftSpeed = CONFIG.particles.driftSpeedMin + Math.random() * (CONFIG.particles.driftSpeedMax - CONFIG.particles.driftSpeedMin);
        this.driftAmp = CONFIG.particles.driftAmplitude * (0.5 + Math.random() * 0.8);

        this.calculatePositions();
      }

      calculatePositions() {
        const t = Math.random() * Math.PI * 2;
        const r = Math.sqrt(Math.random());

        const scale = CONFIG.particles.heartScale;
        const thickness = CONFIG.particles.heartThick;

        const x_base = 16 * Math.pow(Math.sin(t), 3);
        const y_base = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
        const z_base = (Math.random() - 0.5) * thickness * (1.2 - r);

        this.posTree.set(
          x_base * r * scale,
          (y_base * r * scale) + 4,
          z_base * scale * 5
        );

        let rScatter = this.isDust ? (10 + Math.random() * 14) : (8 + Math.random() * 12);
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        this.posScatter.set(
          rScatter * Math.sin(phi) * Math.cos(theta),
          rScatter * Math.sin(phi) * Math.sin(theta),
          rScatter * Math.cos(phi)
        );
      }

      update(dt, mode, focusTargetMesh) {
        let target = this.posTree;

        if (mode === 'TEXT') target = this.posScatter;
        else if (mode === 'SCATTER') target = this.posScatter;
        else if (mode === 'FOCUS') {
          if (this.mesh === focusTargetMesh) {
            const desiredWorldPos = new THREE.Vector3(0, 2, 34);
            const invMatrix = new THREE.Matrix4().copy(mainGroup.matrixWorld).invert();
            target = desiredWorldPos.applyMatrix4(invMatrix);
          } else target = this.posScatter;
        }

        let lerpSpeed = 2.0;
        if (mode === 'TEXT') lerpSpeed = 4.5;
        if (mode === 'FOCUS' && this.mesh === focusTargetMesh) lerpSpeed = 6.0;

        const time = clock.getElapsedTime();
        let drift = 0;
        if (mode !== 'TEXT') drift = Math.sin(time * this.driftSpeed + this.driftPhase) * this.driftAmp;

        const targetWithDrift = target.clone();
        targetWithDrift.y += drift;
        this.mesh.position.lerp(targetWithDrift, lerpSpeed * dt);

        // rotate
        if (mode === 'SCATTER') {
          this.mesh.rotation.x += this.spinSpeed.x * dt;
          this.mesh.rotation.y += this.spinSpeed.y * dt;
          this.mesh.rotation.z += this.spinSpeed.z * dt;
        } else if (mode === 'TREE') {
          this.mesh.rotation.y += 0.45 * dt;
        } else if (mode === 'FOCUS' && this.mesh === focusTargetMesh) {
          this.mesh.lookAt(camera.position);
        }

        // scale
        let s = this.baseScale;

        if (this.isDust) {
          if (mode === 'TREE' || mode === 'TEXT') s = 0;
          else s = this.baseScale * (0.85 + 0.35 * Math.sin(clock.elapsedTime * 4 + this.mesh.id));
        } else if (mode === 'SCATTER' && this.type === 'PHOTO') {
          s = this.baseScale * 2.8;
        } else if (mode === 'FOCUS') {
          s = (this.mesh === focusTargetMesh) ? 7.2 : this.baseScale * 0.55;
        }

        const amp = CONFIG.particles.blinkAmplitude || 0.16;
        const pulse = 1 + Math.sin(clock.getElapsedTime() * this.blinkSpeed + this.pulsePhase) * amp;
        const finalScale = s * pulse;

        this.mesh.scale.lerp(new THREE.Vector3(finalScale, finalScale, finalScale), 6 * dt);
      }
    }

    function createSmallHeartGeometry() {
      const points = [];
      const segments = 14;
      for (let i = 0; i <= segments; i++) {
        const t = (i / segments) * Math.PI;
        const x = 16 * Math.pow(Math.sin(t), 3);
        const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
        const scale = 0.03;
        points.push(new THREE.Vector2(Math.abs(x) * scale, (y * scale) * 0.9));
      }
      const geo = new THREE.LatheGeometry(points, 16);
      geo.rotateX(Math.PI * 0.08);
      return geo;
    }

    function createHeartGeometry() {
      const points = [];
      for (let i = 0; i <= 26; i++) {
        const t = (i / 26) * Math.PI;
        const x = 16 * Math.pow(Math.sin(t), 3);
        const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
        const scale = 0.045;
        points.push(new THREE.Vector2(Math.abs(x) * scale, (y * scale) * 0.8));
      }
      const heartGeo = new THREE.LatheGeometry(points, 20);
      heartGeo.rotateX(Math.PI * 0.1);
      return heartGeo;
    }

    function createStarfield() {
      const starCount = 420;
      const positions = new Float32Array(starCount * 3);
      const colors = new Float32Array(starCount * 3);

      for (let i = 0; i < starCount; i++) {
        const r = 60 + Math.random() * 240;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos((Math.random() * 2) - 1);

        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);

        positions[i*3] = x; positions[i*3 + 1] = y; positions[i*3 + 2] = z;

        const shade = 0.9 + Math.random() * 0.1;
        colors[i*3] = shade; colors[i*3 + 1] = shade; colors[i*3 + 2] = 1.0;
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      const mat = new THREE.PointsMaterial({
        size: 0.6,
        vertexColors: true,
        transparent: true,
        opacity: 0.90,
        depthWrite: false,
        blending: THREE.AdditiveBlending
      });

      scene.add(new THREE.Points(geo, mat));
    }

    function addRimToMesh(proto, colorHex, strength, scaleMult = 1.06) {
      const rimMat = new THREE.MeshBasicMaterial({
        color: colorHex,
        transparent: true,
        opacity: strength,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      const rim = proto.clone(true);
      rim.traverse(n => { if (n.isMesh) { n.material = rimMat; n.renderOrder = 999; } });
      rim.scale.multiplyScalar(scaleMult);
      proto.add(rim);
    }

    function createBearMesh() {
      const g = new THREE.Group();
      const bearMat = new THREE.MeshStandardMaterial({
        color: 0xffe0c8, roughness: 0.75, metalness: 0.02,
        emissive: 0xffe6e0, emissiveIntensity: 0.03
      });

      const head = new THREE.Mesh(new THREE.SphereGeometry(0.5, 10, 10), bearMat);
      head.position.set(0, 0.25, 0);
      g.add(head);

      const body = new THREE.Mesh(new THREE.SphereGeometry(0.65, 10, 10), bearMat.clone());
      body.position.set(0, -0.45, 0);
      g.add(body);

      const earL = new THREE.Mesh(new THREE.SphereGeometry(0.18, 8, 8), head.material);
      const earR = earL.clone();
      earL.position.set(-0.35, 0.7, 0);
      earR.position.set(0.35, 0.7, 0);
      g.add(earL); g.add(earR);

      const eyeMat = new THREE.MeshBasicMaterial({ color: 0x2b1b17 });
      const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.06, 7, 7), eyeMat);
      const eyeR = eyeL.clone();
      eyeL.position.set(-0.15, 0.18, 0.45);
      eyeR.position.set(0.15, 0.18, 0.45);
      g.add(eyeL); g.add(eyeR);

      return g;
    }

    function createCandyMesh() {
      const h = 0.7;
      const geo = new THREE.CylinderGeometry(0.28, 0.28, h, 12, 1, true);
      const mat = new THREE.MeshStandardMaterial({
        color: 0xfff1f6,
        map: caneTexture || null,
        metalness: 0.08,
        roughness: 0.3,
        emissive: 0xffe8ef,
        emissiveIntensity: 0.05
      });
      if (caneTexture) { caneTexture.repeat.set(2, 1); caneTexture.needsUpdate = true; }
      const mesh = new THREE.Mesh(geo, mat);

      const capMat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.12, roughness: 0.28 });
      const end1 = new THREE.Mesh(new THREE.SphereGeometry(0.28, 10, 10), capMat);
      const end2 = end1.clone();
      end1.position.y = h/2; end2.position.y = -h/2;

      const group = new THREE.Group();
      group.add(mesh); group.add(end1); group.add(end2);
      return group;
    }

    function createParticles() {
      const heartGeo = createSmallHeartGeometry();
      const bearProto = createBearMesh();
      const candyProto = createCandyMesh();

      const heartMat = new THREE.MeshPhysicalMaterial({
        color: 0xffb3c6,
        metalness: 0.10,
        roughness: 0.30,
        clearcoat: 0.25,
        clearcoatRoughness: 0.20,
        emissive: 0xffd6e6,
        emissiveIntensity: 0.14,
        envMapIntensity: 0.75
      });

      const smallHeartProto = new THREE.Mesh(heartGeo, heartMat);
      addRimToMesh(smallHeartProto, CONFIG.particles.rimColor, CONFIG.particles.rimStrength, 1.06);
      addRimToMesh(bearProto, CONFIG.particles.rimColor, CONFIG.particles.rimStrength, 1.04);
      addRimToMesh(candyProto, CONFIG.particles.rimColor, CONFIG.particles.rimStrength, 1.03);

      const poolSize = Math.min(Math.max(8, Math.floor(CONFIG.particles.count / 15)), 48);
      const heartPool = new Array(poolSize).fill(0).map(() => heartMat.clone());

      let baseBearMat = null;
      bearProto.traverse(n => { if (!baseBearMat && n.isMesh && n.material && n.material.isMeshStandardMaterial) baseBearMat = n.material; });
      const bearPool = baseBearMat ? new Array(poolSize).fill(0).map(() => baseBearMat.clone()) : [];

      let baseCandyMat = null;
      candyProto.traverse(n => { if (!baseCandyMat && n.isMesh && n.material && n.material.isMeshStandardMaterial) baseCandyMat = n.material; });
      const candyPool = baseCandyMat ? new Array(poolSize).fill(0).map(() => baseCandyMat.clone()) : [];

      const batchSize = 50;
      let created = 0;

      function createBatch() {
        const end = Math.min(created + batchSize, CONFIG.particles.count);
        for (let i = created; i < end; i++) {
          const rr = Math.random();
          let mesh, type;

          if (rr < 0.68) {
            mesh = smallHeartProto.clone(true);
            const m = heartPool[i % poolSize];
            mesh.traverse(n => { if (n.isMesh && n.material && n.material.blending !== THREE.AdditiveBlending) n.material = m; });
            type = 'HEART';
          } else if (rr < 0.86) {
            mesh = bearProto.clone(true);
            const m = bearPool[i % poolSize] || null;
            if (m) mesh.traverse(n => { if (n.isMesh && n.material && n.material.blending !== THREE.AdditiveBlending) n.material = m; });
            type = 'BEAR';
          } else {
            mesh = candyProto.clone(true);
            const m = candyPool[i % poolSize] || null;
            if (m) mesh.traverse(n => { if (n.isMesh && n.material && n.material.blending !== THREE.AdditiveBlending) n.material = m; });
            type = 'CANDY';
          }

          const s = 0.20 + Math.random() * 0.35;
          mesh.scale.set(s, s, s);
          mesh.rotation.set((Math.random()-0.5)*0.35, Math.random()*Math.PI*2, (Math.random()-0.5)*0.35);

          mainGroup.add(mesh);
          particleSystem.push(new Particle(mesh, type, false));
        }

        created = end;
        if (created < CONFIG.particles.count) setTimeout(createBatch, 0);
      }

      createBatch();

      // topper
      const bigHeart = createHeartGeometry();
      const topper = new THREE.Mesh(bigHeart, heartMat);
      topper.scale.set(1.55, 1.55, 1.55);

      bigHeart.computeBoundingBox();
      const bb = bigHeart.boundingBox;
      const approxTopY = (bb?.max?.y ?? 6) * topper.scale.y + 4;
      topper.position.set(0, approxTopY, 0);
      topper.rotation.set(-0.2, 0, 0);
      mainGroup.add(topper);

      mainGroup.add(photoMeshGroup);
    }

    function createDustAndTextCloud() {
      // dust mesh giáº£m máº¡nh
      const dustGeo = new THREE.TetrahedronGeometry(0.08, 0);
      const dustMat = new THREE.MeshBasicMaterial({ color: 0xffd9e6, transparent: true, opacity: 0.35 });

      for (let i = 0; i < CONFIG.particles.dustCount; i++) {
        const mesh = new THREE.Mesh(dustGeo, dustMat);
        mesh.scale.setScalar(0.06 + Math.random() * 0.08);
        mainGroup.add(mesh);
        particleSystem.push(new Particle(mesh, 'DUST', true));
      }

      // text cloud
      const count = CONFIG.particles.textCount;
      textGeom = new THREE.BufferGeometry();
      textPosArr = new Float32Array(count * 3);
      textTargetArr = new Float32Array(count * 3);
      textScatterArr = new Float32Array(count * 3);

      for (let i = 0; i < count; i++) {
        const idx = i * 3;
        const r = 18 + Math.random() * 16;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);

        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta) + 2;
        const z = r * Math.cos(phi);

        textPosArr[idx] = x; textPosArr[idx+1] = y; textPosArr[idx+2] = z;
        textScatterArr[idx] = x; textScatterArr[idx+1] = y; textScatterArr[idx+2] = z;
        textTargetArr[idx] = x; textTargetArr[idx+1] = y; textTargetArr[idx+2] = z;
      }

      const posAttr = new THREE.BufferAttribute(textPosArr, 3);
      posAttr.setUsage(THREE.DynamicDrawUsage);
      textGeom.setAttribute('position', posAttr);

      const textMat = new THREE.PointsMaterial({
        color: CONFIG.colors.textParticles,
        size: 0.095,
        transparent: true,
        opacity: 0.92,
        depthWrite: false,
        blending: THREE.AdditiveBlending
      });

      textCloud = new THREE.Points(textGeom, textMat);
      textCloud.visible = false;
      mainGroup.add(textCloud);
    }

    // mobile text points nháº¹ hÆ¡n
    function createTextPoints(text, gap = 3) {
      const width = 1024, height = 512;
      const canvas = document.createElement('canvas');
      canvas.width = width; canvas.height = height;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, width, height);

      ctx.fillStyle = '#fff';
      ctx.font = '900 140px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, width / 2, height / 2);

      const data = ctx.getImageData(0, 0, width, height).data;
      const points = [];

      for (let y = 0; y < height; y += gap) {
        for (let x = 0; x < width; x += gap) {
          const i = (y * width + x) * 4;
          if (data[i] > 128) {
            const nx = (x - width / 2) / width;
            const ny = (height / 2 - y) / height;
            points.push(new THREE.Vector3(nx * 35, ny * 14 + 2, 0));
          }
        }
      }

      for (let i = points.length - 1; i > 0; i--) {
        const j = (Math.random() * (i + 1)) | 0;
        [points[i], points[j]] = [points[j], points[i]];
      }
      return points;
    }

    function formTextWithDust(text) {
      if (!textTargetArr) return;
      const msg = text || "ANH YÃŠU EM";
      const pts = createTextPoints(msg);
      if (!pts.length) return;

      const count = (textTargetArr.length / 3) | 0;
      for (let i = 0; i < count; i++) {
        const idx = i * 3;
        const p = pts[i % pts.length];
        textTargetArr[idx]     = p.x + (Math.random() - 0.5) * 0.20;
        textTargetArr[idx + 1] = p.y + (Math.random() - 0.5) * 0.20;
        textTargetArr[idx + 2] = p.z + (Math.random() - 0.5) * 0.35;
      }
    }

    function updateTextCloud(dt) {
      if (!textCloud || !textGeom) return;

      const wantText = (STATE.mode === 'TEXT');
      textCloud.visible = wantText;

      const target = wantText ? textTargetArr : textScatterArr;
      const k = wantText ? 10.0 : 4.5;
      const t = Math.min(1, k * dt);

      const count = (textPosArr.length / 3) | 0;
      const CHUNK = 2400;
      const start = textUpdateCursor;
      const end = Math.min(start + CHUNK, count);

      for (let i = start; i < end; i++) {
        const idx = i * 3;
        textPosArr[idx]     += (target[idx]     - textPosArr[idx])     * t;
        textPosArr[idx + 1] += (target[idx + 1] - textPosArr[idx + 1]) * t;
        textPosArr[idx + 2] += (target[idx + 2] - textPosArr[idx + 2]) * t;
      }

      textUpdateCursor = (end >= count) ? 0 : end;
      textGeom.attributes.position.needsUpdate = true;
    }

    function loadInitialPhotos() {
      INITIAL_PHOTOS.forEach(url => {
        new THREE.TextureLoader().load(url, (t) => addPhotoToScene(t));
      });
    }

    function addPhotoToScene(texture) {
      texture.colorSpace = THREE.SRGBColorSpace;
      texture.wrapS = THREE.ClampToEdgeWrapping;
      texture.wrapT = THREE.ClampToEdgeWrapping;
      texture.generateMipmaps = true;
      texture.minFilter = THREE.LinearMipmapLinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.anisotropy = Math.min(4, renderer.capabilities.getMaxAnisotropy());
      texture.needsUpdate = true;

      const frameGeo = new THREE.BoxGeometry(1.4, 1.4, 0.05);
      const frameMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.champagneGold,
        metalness: 1.0,
        roughness: 0.12
      });
      const frame = new THREE.Mesh(frameGeo, frameMat);

      const photoGeo = new THREE.PlaneGeometry(1.2, 1.2);
      const photoMat = new THREE.MeshBasicMaterial({ map: texture });
      const photo = new THREE.Mesh(photoGeo, photoMat);
      photo.position.z = 0.04;

      const group = new THREE.Group();
      group.add(frame);
      group.add(photo);
      group.scale.setScalar(0.8);

      group.userData.isPhoto = true;
      group.userData.photoIndex = photoRoots.length;
      photoRoots.push(group);

      photoMeshGroup.add(group);
      particleSystem.push(new Particle(group, 'PHOTO', false));
    }

    function findPhotoRoot(obj) {
      let cur = obj;
      while (cur && cur.parent && cur.parent !== photoMeshGroup) cur = cur.parent;
      return cur;
    }

    function focusPhoto(group) {
      if (!group) return;
      STATE.mode = 'FOCUS';
      STATE.focusTarget = group;
      currentPhotoIndex = group.userData.photoIndex ?? 0;
    }

    // mediapipe (throttle 10fps)
    async function initMediaPipe() {
      video = document.getElementById('webcam');

      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
      );

      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
          delegate: "CPU"
        },
        runningMode: "VIDEO",
        numHands: 2
      });

      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } });
      video.srcObject = stream;
      video.addEventListener("loadeddata", predictWebcam);
    }

    let lastVideoTime = -1;
    let lastDetectTime = 0;

    async function predictWebcam() {
      const now = performance.now();
      if (video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;
        if (handLandmarker && (now - lastDetectTime > 100)) { // ~10fps
          lastDetectTime = now;
          const result = handLandmarker.detectForVideo(video, now);
          processGestures(result);
        }
      }
      requestAnimationFrame(predictWebcam);
    }

    function processGestures(result) {
      if (result.landmarks && result.landmarks.length >= 2) {
        STATE.hand.detected = true;
        if (!STATE.textFormed) {
          STATE.prevMode = STATE.mode;
          STATE.mode = 'TEXT';
          STATE.textFormed = true;
          formTextWithDust('ANH YÃŠU EM');
        }
      } else if (result.landmarks && result.landmarks.length > 0) {
        if (STATE.textFormed) {
          STATE.textFormed = false;
          STATE.mode = STATE.prevMode || 'SCATTER';
        }

        STATE.hand.detected = true;
        const lm = result.landmarks[0];
        STATE.hand.x = (lm[9].x - 0.5) * 2;
        STATE.hand.y = (lm[9].y - 0.5) * 2;

        const thumb = lm[4];
        const index = lm[8];
        const pinchDist = Math.hypot(thumb.x - index.x, thumb.y - index.y);

        const wrist = lm[0];
        const tips = [lm[8], lm[12], lm[16], lm[20]];
        let avgDist = 0;
        tips.forEach(t => avgDist += Math.hypot(t.x - wrist.x, t.y - wrist.y));
        avgDist /= 4;

        if (pinchDist < 0.05) {
          if (STATE.mode !== 'FOCUS') {
            STATE.mode = 'FOCUS';
            if (photoRoots.length) STATE.focusTarget = photoRoots[(Math.random() * photoRoots.length) | 0];
          }
        } else if (avgDist < 0.25) {
          STATE.mode = 'TREE';
          STATE.focusTarget = null;
        } else if (avgDist > 0.4) {
          STATE.mode = 'SCATTER';
          STATE.focusTarget = null;
        }
      } else {
        if (STATE.textFormed) {
          STATE.textFormed = false;
          STATE.mode = STATE.prevMode || 'SCATTER';
        }
        STATE.hand.detected = false;
      }
    }

    function setupEvents() {
      let resizeTimer = null;
      const requestResize = () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(resizeAll, 80);
      };

      window.addEventListener('resize', requestResize);

      // xá»­ lÃ½ viewport â€œnháº£yâ€ trÃªn mobile
      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', requestResize);
        window.visualViewport.addEventListener('scroll', requestResize);
      }
      window.addEventListener('orientationchange', () => setTimeout(resizeAll, 200));

      document.addEventListener('visibilitychange', () => {
        isPaused = document.hidden;
        if (!isPaused) resizeAll();
      });

      renderer.domElement.addEventListener('pointerdown', (e) => {
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(pointer, camera);

        const hits = raycaster.intersectObjects(photoMeshGroup.children, true);
        if (hits.length) {
          const root = findPhotoRoot(hits[0].object);
          if (root && root.userData.isPhoto) focusPhoto(root);
        }
      }, { passive: true });
    }

    function animate() {
      requestAnimationFrame(animate);
      if (isPaused) return;

      const dtRaw = clock.getDelta();
      mobileAcc += dtRaw;
      if (mobileAcc < MOBILE_FPS_STEP) return; // cap 30fps
      const dt = Math.min(mobileAcc, 0.05);
      mobileAcc = 0;

      if (STATE.mode === 'TEXT') {
        STATE.rotation.y += 0.05 * dt;
        STATE.rotation.x += (0 - STATE.rotation.x) * 1.0 * dt;
      } else if (STATE.mode === 'SCATTER' && STATE.hand.detected) {
        const targetRotY = STATE.hand.x * Math.PI * 0.9;
        const targetRotX = STATE.hand.y * Math.PI * 0.25;
        STATE.rotation.y += (targetRotY - STATE.rotation.y) * 3.0 * dt;
        STATE.rotation.x += (targetRotX - STATE.rotation.x) * 3.0 * dt;
      } else {
        if (STATE.mode === 'TREE') {
          STATE.rotation.y += 0.28 * dt;
          STATE.rotation.x += (0 - STATE.rotation.x) * 2.0 * dt;
        } else {
          STATE.rotation.y += 0.1 * dt;
        }
      }

      mainGroup.rotation.y = STATE.rotation.y;
      mainGroup.rotation.x = STATE.rotation.x;

      if (focusBackdrop) focusBackdrop.visible = (STATE.mode === 'FOCUS');

      for (let i = 0; i < particleSystem.length; i++) {
        particleSystem[i].update(dt, STATE.mode, STATE.focusTarget);
      }
      updateTextCloud(dt);

      if (STATE.mode === 'TREE') {
        const beat = 1 + Math.sin(clock.getElapsedTime() * 8) * 0.045;
        mainGroup.scale.set(beat, beat, beat);
      } else {
        mainGroup.scale.set(1, 1, 1);
      }

      composer.render();
    }

    init();
  </script>
</body>
</html>